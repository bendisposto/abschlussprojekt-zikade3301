[[section-building-block-view]]
== Bausteinsicht

Dieser Abschnitt beschreibt die Aufteilung der Anwendung

=== Whitebox Gesamtsystem

_**<Übersichtsdiagramm>**_

Begründung:: _<Erläuternder Text>_

Enthaltene Bausteine:: _<Beschreibung der enthaltenen Bausteine (Blackboxen)>_

Wichtige Schnittstellen:: _<Beschreibung wichtiger Schnittstellen>_

== Volltextsuche

 Zweck/Verantwortung::

_Die Suche soll dem Nutzer eine Möglichkeit geben, durch das Eingeben von Stichworten, eine Liste von Modulen zu erhalten._

 Schnittstelle::

 _Die Schnittstelle für den Nutzer ist die Suchleiste, also die GET Anfrage an den SearchController._

 Qualitäts-/Leistungsmerkmale::
 _Die Suche soll auch mit Teilworten fertig werden; sucht der Nutzer also nach dem Keyword "Architektur", so muss die Suche auch den Eintrag "Architekturformen" finden können._

== Erstellen von Anträgen

 Schnittstelle(n)::

 _Die Schnittstellen liegen hier in der View der Modulbeauftragten und der Admin View. Nur von diesen beiden Seiten können nach Authentifizierung des Nutzers Anträge erstellt werden. Die Anträge können zum Erstellen von Modulen oder zur Änderung eben dieser verwendet werden._

 Qualitäts-/Leistungsmerkmale::

 _Anträge sollen zu jeder Zeit erstellbar sein und gespeichert werden._

== PDF Download

 Schnittstelle::
 _Das komplette Modulhandbuch wird auf der Hauptseite zum Download angeboten._

 Qualitäts-/Leistungsmerkmale::

 _Das aktuelle PDF-Modulhandbuch soll zu jeder Zeit verfügbar sein in ansehnlicher Formatierung._

== REST-API

 Schnittstelle::
 _Die aktuellen Module werden per HTTP GET Request zur Verfügung gestellt._

 Qualitäts-/Leistungsmerkmale::

 _Die Modulinformationen sollen zu jeder Zeit in korrekt formatiertem JSON für den API-Nutzer abrufbar sein. Der Nutzer soll genau spezifizieren können, welche Informationen er benötigt._

== Volltextsuche Blackbox

 Suche im Detail::

 _In der index.html gibt es ein Formular, mit dem ein Request Parameter (searchField) durch eine GET-Anfrage an den SearchController geschickt wird.
 Die Methode search im Controller ruft dann die Methode search im SearchService auf. Der searchField Parameter wird dabei übergeben.
 Diese Methode wendet durch Hibernate Search eine Suchanfrage auf die Datenbank an. Hibernate Search hat beim Start des Programms die relevanten Felder indexiert und aktualisiert sich bei neu hinzugefügten (oder geänderten) Modulen selbst.
 Ausserdem werden beim Indexieren alle nicht sichtbaren Module ignoriert.
 Der Index wird genutzt, um mit der Suchanfrage die relevanten Felder in den Modulen zu durchsuchen. Wildcards ermöglichen, dass Teilworte erkannt werden. Die Methode gibt eine Liste zurück, welche als Modulattribut in searchresults.html übergeben wird.
 Der Nutzer wird dann auch auf searchresults weitergeleitet und bekommt die Liste als Linksammlung angezeigt.
 Die Links leiten den Nutzer weiter auf die Moduldetails._

== PDF-Download Blackbox

 PDF-Generierung im Detail::

 _In der index.html gibt es neben der Suchleiste einen PDF-Knopf, mit dem per GET-Request auf /module/pdf die PDF-Generierung des aktuellen Modulhandbuchs gestartet wird.
 Im PdfDownloadController wird nun über den ModulService_

== REST-API Blackbox

 REST-API im Detail::

 _Über /module/api ist die Schnittstelle verfügbar, bei der über query die genauen Attribute spezifiziert werden, die der Nutzer abrufen möchte.
 GraphQL fängt diese Anfrage über den GraphQlProvider ab und prüft ob die Anfrage korrekt gestellt wurde.
 Die möglichen Anfragen wurden dabei in der schema.graphqls Datei spezifiziert und können über das ebenso eingebundene GraphiQL über /module/graphiql erkundet werden.
 Ist die Anfrage fehlerhaft, so gibt GraphQL eine Fehlermeldung zurück.
 Bei korrekt gestellter Anfrage sammelt GraphQL über die GraphQlDataFetchers die angeforderten Informationen und nutzt dabei den ModulService welcher die Daten aus der Datenbank ausliest.
 Die vom ModulService zurückgegebenen Modulobjekte werden mit Hilfe der schema.graphqls und eigenst definierter GraphQL-scalars (LocalDateTime und Modulkategorie) in einen JSON-String umgewandelt.
 Dieser String wird dem Nutzer dann in der HTTP-Response zurückgegeben._

 
==== <Name Blackbox n>

_<Blackbox-Template>_


==== <Name Schnittstelle 1>

...

==== <Name Schnittstelle m>

=== Ebene 2



==== Whitebox _<Baustein 1>_



_<Whitebox-Template>_

==== Whitebox _<Baustein 2>_

_<Whitebox-Template>_

...

==== Whitebox _<Baustein m>_

_<Whitebox-Template>_

=== Ebene 3



==== Whitebox <_Baustein x.1_>



_<Whitebox-Template>_

==== Whitebox <_Baustein x.2_>

_<Whitebox-Template>_

==== Whitebox <_Baustein y.1_>

_<Whitebox-Template>_
